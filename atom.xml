<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赤羽</title>
  
  <subtitle>人生没有白走的路，每一步都算数</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-09T06:02:41.676Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tanghao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> c++如果两个在不同头文件如何相互引用</title>
    <link href="http://yoursite.com/2019/05/09/c-%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/09/c-如果两个在不同头文件如何相互引用/</id>
    <published>2019-05-09T06:02:00.000Z</published>
    <updated>2019-05-09T06:02:41.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-如果两个在不同头文件如何相互引用"><a href="#c-如果两个在不同头文件如何相互引用" class="headerlink" title="c++如果两个在不同头文件如何相互引用"></a>c++如果两个在不同头文件如何相互引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个不同类相互引用，需要放入对方的头文件，但是如果分别放入<code>#include seconde.h  #include seconde.h</code>那么会产生重复编译的问题<br>但是可以改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class b；//提前声明</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">#include first.h//引入头文件</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br><span class="line">//同时这几个.h的实现文件.cpp只用引入其中一个头文件即可，不需要同时引入两个</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;c-如果两个在不同头文件如何相互引用&quot;&gt;&lt;a href=&quot;#c-如果两个在不同头文件如何相互引用&quot; class=&quot;headerlink&quot; title=&quot;c++如果两个在不同头文件如何相互引用&quot;&gt;&lt;/a&gt;c++如果两个在不同头文件如何相互引用&lt;/h3&gt;&lt;figure
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="头文件" scheme="http://yoursite.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MarKDown语法</title>
    <link href="http://yoursite.com/2019/05/08/MarKDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/08/MarKDown语法/</id>
    <published>2019-05-08T01:56:00.000Z</published>
    <updated>2019-05-08T02:10:32.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h3><ol><li><strong>标题</strong></li></ol><p>#这是一级标题</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><p>##这是二级标题（<em>以此类推，级数越大，标题越小,空格后加内容</em>）</p><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p>2.<strong>字体</strong></p><p>   1.<em>傾斜</em></p><pre><code>*字*</code></pre><p>   <em>字</em></p><p>   2.<em>粗体</em></p><pre><code>**字**</code></pre><p>   <strong>字</strong></p><p>   3.<em>倾斜加粗</em></p><pre><code>***字***</code></pre><p>   <strong><em>字</em></strong></p><p>   4.<em>删除线</em></p><pre><code>~~字~~</code></pre><p>   <del>字</del></p><p>3.<em>引用</em></p><pre><code>&gt;引用内容</code></pre><blockquote><p>引用内容</p></blockquote><p>4.<em>分割线</em></p><p>-–(三个以上都行，下同)</p><hr><p>***</p><hr><p>5.<em>图片</em></p><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可    不加</code></pre><p>6.<em>超链接</em></p><pre><code>[链接名][网址]</code></pre><p>7.<em>列表</em></p><pre><code>+ or - or * 列表（注意空格）</code></pre><ul><li>列表<pre><code>1. or 2. --- 列表1</code></pre></li></ul><ol><li>列表</li></ol><p>8.<em>表格</em></p><pre><code>|  |  || --- | --- |(分割线)|  |  |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td></tr></tbody></table><ol start="9"><li><p><em>代码</em><br> 单行代码  </p><p> `int mian`</p><p> <code>main</code> </p><p> 代码块</p><p> ```  ```</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>（要打出特殊符号，在前面加TAb即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="MarkDown语法" scheme="http://yoursite.com/tags/MarkDown%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/05/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/线段树/</id>
    <published>2019-05-07T15:48:00.000Z</published>
    <updated>2019-05-08T02:05:44.509Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define lSon a*2+1</span><br><span class="line">#define rSon a*2+2</span><br><span class="line">using namespace std;</span><br><span class="line">double scatter[100];//不确定生成数据，所以动态开辟</span><br><span class="line">void upDate(int);</span><br><span class="line">void signDown(int);</span><br><span class="line">struct edg</span><br><span class="line">&#123;</span><br><span class="line">    double L;//实际的左右端点</span><br><span class="line">    double R;</span><br><span class="line">&#125;;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int lHand;//区间左端点</span><br><span class="line">    int rHand;//区间右端点</span><br><span class="line">    int nums;//这个区间的线段数</span><br><span class="line">    int counts;</span><br><span class="line">    int rF;//区间左端点是否被覆盖</span><br><span class="line">    int lF;//区间右端点是否被覆盖</span><br><span class="line">    double len;//区间长度</span><br><span class="line">    Node():lHand(0),rHand(0),nums(0),rF(0),lF(0),len(0),counts(0)//初始化</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[MAX*4];//线段树是完全树</span><br><span class="line">void Tree(int a,int lhand,int rhand)//建树</span><br><span class="line">&#123;</span><br><span class="line">    int mid=(lhand+rhand)/2;</span><br><span class="line">    tree[a].lHand=lhand;</span><br><span class="line">    tree[a].rHand=rhand;</span><br><span class="line">    if(lhand==rhand)</span><br><span class="line">        return;</span><br><span class="line">    Tree(lSon,lhand,mid);</span><br><span class="line">    Tree(rSon,mid+1,rhand);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int a,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a].counts)</span><br><span class="line">        signDown(a);</span><br><span class="line">    int mid=(tree[a].lHand+tree[a].rHand)/2;</span><br><span class="line">    if(tree[a].lHand&gt;=l&amp;&amp;tree[a].rHand&lt;=r)//如果被完全包含</span><br><span class="line">    &#123;</span><br><span class="line">        if(tree[a].counts)</span><br><span class="line">            return;</span><br><span class="line">        tree[a].counts++;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].lF=1;</span><br><span class="line">        tree[a].rF=1;</span><br><span class="line">        tree[a].len=scatter[tree[a].rHand+1]-scatter[tree[a].lHand];</span><br><span class="line">        //需要向右扩展</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mid&gt;=l)</span><br><span class="line">        insert(lSon,l,r);</span><br><span class="line">    if(mid&lt;r)</span><br><span class="line">        insert(rSon,l,r);</span><br><span class="line">    upDate(a);//合并左右子树信息</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void upDate(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a*2+1].rF&amp;tree[a*2+2].lF)//如果端点都为1，合并</span><br><span class="line">    &#123;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">    tree[a].nums=tree[a*2+1].nums+tree[a*2+2].nums;</span><br><span class="line">    tree[a].lF=tree[a*2+1].lF;</span><br><span class="line">    tree[a].rF=tree[a*2+2].rF;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void signDown(int a)</span><br><span class="line">&#123;</span><br><span class="line">    tree[a*2+1].len=scatter[tree[a*2+1].rHand+1]-scatter[tree[a*2+1].lHand];</span><br><span class="line">    tree[a*2+2].len=scatter[tree[a*2+2].rHand+1]-scatter[tree[a*2+2].lHand];</span><br><span class="line">    tree[a*2+1].lF=1;</span><br><span class="line">    tree[a*2+1].rF=1;</span><br><span class="line">    tree[a*2+2].lF=1;</span><br><span class="line">    tree[a*2+2].rF=1;</span><br><span class="line">    tree[a*2+1].nums=1;</span><br><span class="line">    tree[a*2+1].counts=1;</span><br><span class="line">    tree[a*2+2].nums=1;</span><br><span class="line">    tree[a*2+2].counts=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T,i=0,t=0;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    edg e[T];</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        double L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        scatter[i++]=L;</span><br><span class="line">        scatter[i++]=R;</span><br><span class="line">        e[t].L=L;//存储边的信息</span><br><span class="line">        e[t++].R=R;</span><br><span class="line">    &#125;</span><br><span class="line">sort(scatter,scatter+i);</span><br><span class="line">int size=unique(scatter,scatter+i)-scatter;</span><br><span class="line">Tree(0,0,size);</span><br><span class="line">for(int j=0;j&lt;t;j++)</span><br><span class="line">&#123;</span><br><span class="line">    int LH=lower_bound(scatter,scatter+size,e[j].L)-scatter;</span><br><span class="line">    int RH=lower_bound(scatter,scatter+size,e[j].R)-scatter;</span><br><span class="line">    insert(0,LH,RH-1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;tree[0].len&lt;&lt;&quot; &quot;&lt;&lt;tree[0].nums&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树因为建树要求区间是整数所以如果要插入浮点数那么需要进行离散化，即根据数据之间的相对关系找到对应整数的对应关系。找到合适的线段插入，但是可能后面需要插的线段再原线段的下方，为了能获取线段覆盖数信息，需要进行标记传，因为线段树可能会找不到左右子树之间的距离，所以考虑每个结点向右扩展1位，即[a,b)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://yoursite.com/2019/05/03/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/03/字典树/</id>
    <published>2019-05-03T03:44:00.000Z</published>
    <updated>2019-05-03T03:47:07.727Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node//结点</span><br><span class="line">&#123;</span><br><span class="line">    bool isEnd;//是否是最后一个结点，判断是否完全匹配</span><br><span class="line">    Node*son[26];//子结点，一共26个字母</span><br><span class="line">    char val;//当前结点值</span><br><span class="line">    long long num;//当前结点与父结点的距离</span><br><span class="line">    Node(char x=&apos;a&apos;):isEnd(false),num(0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            son[i]=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()//析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(son[i])</span><br><span class="line">                delete son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Tree//树</span><br><span class="line">&#123;</span><br><span class="line">    Node*root;</span><br><span class="line">    Tree()</span><br><span class="line">    &#123;</span><br><span class="line">        root=new Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Tree head;//头,字典树头节点不包含信息</span><br><span class="line">void insert_str(string s)//字符串为空，返回</span><br><span class="line">&#123;</span><br><span class="line">    if(s.size()==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，那么开辟空间</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;son[i]=new Node(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;isEnd=true;//插入的最后一个字符，标记</span><br><span class="line">&#125;</span><br><span class="line">bool query(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if(!s.size())</span><br><span class="line">        return false;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，不匹配</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    return temp-&gt;isEnd;//可能是部分匹配</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    string s;</span><br><span class="line">    while(T--)//建树，插入字符串</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        insert_str(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(query(s))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">             cout&lt;&lt;&quot;no exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典树本质是一种文本快速匹配算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus学习</title>
    <link href="http://yoursite.com/2019/05/03/c-Primer-Plus%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/03/c-Primer-Plus学习/</id>
    <published>2019-05-02T16:25:00.000Z</published>
    <updated>2019-05-08T12:10:38.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>1.<strong>main函数</strong></p><ul><li>在c++中<br><code>int  main（）</code><br><code>int main(void)</code><br>是等价的，都代表是不接受参数，但是在c中代表对是否有参数保持沉默</li><li>c++标准中，主函数返回值必须为int，如果运行到主函数最后一个花括号，那么认为以这条语句结束<br><code>return 0</code></li></ul><p>2.<strong>头文件命名</strong></p><ul><li>c++旧式命名规则时和c语言一样的，以.h结束，比如<code>iostream.h</code>,只能c++用，c不行</li><li>c的头文件<code>.h</code>c++一般都可以兼容<br>+c有些头文件被转换为了c++风格，名字一般是c版本名+前缀c<br>比如<code>cmath math.h</code></li></ul><p>3.<strong>endl与\n的区别</strong></p><ul><li>在大多数时候两者都没有区别，但是endl能保证程序继续运行前刷新（输出到显示屏）但是<code>\n</code>不能保证。</li></ul><p>4.<strong>分隔符 ；</strong></p><ul><li>c++以；作为代码语句结束的标志，在编辑代码过程中，回车和空格是没有区别的，能打空格就能打回车，例如，下面这条语句是正确的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a;int b;</span><br><span class="line">    cout</span><br><span class="line">    &lt;&lt;</span><br><span class="line">    endl;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ul><p>但是也要遵循一些规则,不能把空格，回车，TAB放入元素当中，比如函数名字，不能在字符串中打回车，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ma in()//error</span><br><span class="line">&#123;</span><br><span class="line">cou</span><br><span class="line">t&lt;&lt;&quot;hello</span><br><span class="line">world&quot;;//eroor,字符串中打了空格（carriage return）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.<strong>赋值语句 =</strong></p><ul><li>c++区别与c的地方就是c++允许进行连续赋值，即下面代码是对的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=b=10//从右到左赋值</span><br></pre></td></tr></table></figure></li></ul><p>6.<strong>在多函数里使用using编译命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;//对后面所有定义的函数都有影响</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespcae std;//对主函数影响</span><br><span class="line">    cout&lt;&lt;1;</span><br><span class="line">    std::cout&lt;&lt;1;//完整输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;main函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在c++中&lt;br&gt;&lt;code&gt;int  main（）&lt;
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
      <category term="c++ primer plus" scheme="http://yoursite.com/categories/c/c-primer-plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>快速幂算法</title>
    <link href="http://yoursite.com/2019/04/28/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/28/快速幂算法/</id>
    <published>2019-04-28T04:02:00.000Z</published>
    <updated>2019-05-03T03:44:52.763Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt; iostream&gt;</span><br><span class="line">#include&lt; stdio.h&gt;</span><br><span class="line">#define  ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int kpow(ll a,ll b);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    kpow(2,32);</span><br><span class="line">&#125;</span><br><span class="line">int kpow(ll a,ll b)//int kpow(lla,llb,int c)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans=1,base=a,temp=b;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1!=0)#任何大于0的数除以2以后，最终都会为1</span><br><span class="line">        ans*=base;//ans=ans*base%c</span><br><span class="line">        base*=base;//base=(base*base)%c</span><br><span class="line">        cout&lt;&lt;base&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld的%lld次方为：%lld\n&quot;,a,temp,ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  快速幂本质上<br><img src="\images\pasted-2.png" alt="upload successful">,如果是取数取余数(中间结果取余相乘即可)，见代码注释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Ipython安装 </title>
    <link href="http://yoursite.com/2019/04/26/Ipython%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/04/26/Ipython安装/</id>
    <published>2019-04-26T15:33:00.000Z</published>
    <updated>2019-04-26T15:39:14.614Z</updated>
    
    <content type="html"><![CDATA[<p>1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库</p><p>2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库&lt;/p&gt;
&lt;p&gt;2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa&lt;/p&gt;

      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA安装及环境配置（window10系统+jdk8.0）</title>
    <link href="http://yoursite.com/2019/04/26/JAVA%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88window10%E7%B3%BB%E7%BB%9F-jdk8-0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/26/JAVA安装及环境配置（window10系统-jdk8-0）/</id>
    <published>2019-04-26T15:01:00.000Z</published>
    <updated>2019-05-03T03:41:51.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li>jdk的下载</li></ol><p><img src="\images\pasted-1.png" alt><br><a href="http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可" target="_blank" rel="noopener">http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可</a><br>    2.jdk的安装</p><pre><code>* 在D盘新建一个java文件夹，在java文件下新建两个文件夹，分别命名为jdk和jre.* 开始点击安装程序， 安装时有两次选择路径的机会，第一次是让你选择jdk安装路径，选择为D:\java\jdk，第二次是让你选择jre的安装路径，选择为D:\java\jre* .安装完成后，进行环境变量的配置，计算机右击属性，-高级系统设置-环境变量-选择下边的系统变量，如果桌面上没有 我的电脑 打开文件夹，点击那里的我的电脑* 新建* 变量名：JAVA_HOME* 变量值：D:\java\jdk（没有分号）* 变量名：ClassPath* 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;* 查看是否有path变量，如果没有创建一个，然后添加 C:\ProgramData\Oracle\Java\javapath;* 应为Javac和java不在同一个包里，所以添加变量* D:\java\jdk\bin* D:\java\jre\bin* 按win+R，输入cmd,打开命令提示符，输入Java，javac，Java-version* 均能运行表示Java安装成功，* 返回最开始的网站，下载eclipse编译器（idle位数的选择取决于你jdk的版本是32还是64），既可以写Java程序了，无需安装，解压即可。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;jdk的下载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;\images\pasted-1.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;amp;pn
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>const char*, char const*, char*const的区别问题</title>
    <link href="http://yoursite.com/2019/04/26/const-char-char-const-char-const%E7%9A%84%E5%8C%BA%E5%88%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/26/const-char-char-const-char-const的区别问题/</id>
    <published>2019-04-26T14:19:03.000Z</published>
    <updated>2019-04-26T14:57:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>const char<em>, char const</em>, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。<br>char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。指针指向的值可以变（例如允许：p[1]=’O’;）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const char&lt;em&gt;, char const&lt;/em&gt;, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。&lt;br&gt;char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客初创</title>
    <link href="http://yoursite.com/2019/04/26/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%88%9B/"/>
    <id>http://yoursite.com/2019/04/26/博客初创/</id>
    <published>2019-04-26T13:29:37.000Z</published>
    <updated>2019-04-26T15:37:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>第一次写博客，花了不少时间搭建服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次写博客，花了不少时间搭建服务器&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
