<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赤羽</title>
  
  <subtitle>人生没有白走的路，每一步都算数</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-10T07:16:26.168Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tanghao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++ Primer Plus(第三章)</title>
    <link href="http://yoursite.com/2019/05/10/c-Primer-Plus-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/05/10/c-Primer-Plus-第三章/</id>
    <published>2019-05-10T07:14:00.000Z</published>
    <updated>2019-05-10T07:16:26.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>1.<strong>变量名</strong></p><ul><li>c99（标准c）中只保证名称的前63个字符有意义，前63个字符相同的名称被认为是相同的，c++对名字长度没有限制（但某些平台会有限制）</li><li>c++中以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的被保留给实现，用作全局标识符（例：如果使用_time_s,_Doun等变量名，编译器不会报错，但会导致行为不确定性）</li></ul><p>2.<strong>变量长度</strong><br>+<code>short</code>,<code>long</code>,<code>int</code>等并不总是保证16，32，32.但是c++标准保证了<code>最小长度</code>，即 short 至少16位，int与short至少是一样长，long至少32为，且至少与int一样长，long long至少64位，且至少和long一样长</p><p>3.<strong>sizeof运算符</strong></p><ul><li>对于sizeof运算符（算内存）对类型名必须要放入括号中，但是对  <strong><em>变量名，括号是可选的</em></strong></li></ul><p>4.<strong>头文件climits（极限数据头文件）</strong></p><ul><li>头文件climit 定义了符号常量来表示类型的限制 比如<code>INT_MAX</code>表示int的最大值，比较常用的有 INT_MIN(int最小值) ，UNIT_MAX(无符号int最大值),LLNOG_MAX(long long最大值)，ULLNOG_MAX(无符号long long最大值)等</li></ul><p>5.<strong>c++变量初始化</strong></p><ul><li>c++还包含一种与C语言不同的初始方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b(100);//The New</span><br><span class="line">int c&#123;12&#125;;</span><br><span class="line">int v=&#123;12&#125;;</span><br><span class="line">int e=&#123;&#125;;//e=0</span><br></pre></td></tr></table></figure></li></ul><p>6.<strong>无符号类型</strong></p><ul><li>unsigned 本身是 unsigned int的缩写</li></ul><p>7.<strong>c++记数方式</strong></p><ul><li>c++能够和C语言一样，以8，10，16进制计数，如果第一位是1-9，那么基数是10，如果第一位是0，第二位是1~7，基数是7，如果前两位是0x或者0X，那么是十六进制；</li></ul><p>8.<strong>c++常量</strong></p><ul><li><code>cout&lt;&lt;12;</code>c++除非有理由（数太大或者后缀）存储为其他类型，则一般存储为int</li><li>后缀LU，UL均表示无符号整数，与顺序无关</li></ul><p>8.<strong>基于字符的8进制与16进制转义</strong></p><ul><li>Ctr+Z的ASII码为26，对应八进制为032，16进制为0x1a，，用单引号括起，即对应编码，如’\037’</li></ul><p>9 <strong>bool</strong></p><ul><li>c++中，任何数字值和指针值都可以被转换为（隐式）为bool，非零为true，零为false。而bool值true转换为1，false为0</li></ul><p>10.<strong>浮点数</strong></p><ul><li>浮点数可以表示为234.0等价于2.34E（e）2(表示2.34与10^2相乘的结果)，同时<strong>数字必须紧挨，不能有空格</strong>，比如 2.34 E2是错误的</li></ul><p>11.<strong>浮点数的输出</strong></p><ul><li>cout输出一般会省去浮点数结尾的零，使用<code>cout.self(ios_base::fixed,ios_base::floatfield);</code>可以覆盖掉</li></ul><p>12.<strong>浮点数常量</strong></p><ul><li>long double的后缀是 l或者L，float是f或者F，c++默认是double</li></ul><p>13.<strong>c++求模</strong></p><ul><li>如果两操作数有一个负数，那么运算满足 （a/b)*b+a%b=a;</li><li>两操作数都因该是整数，浮点数会编译错误</li></ul><ol start="14"><li><strong>浮点数精度问题</strong></li></ol><ul><li>float保证6位精度，double保证15位精度</li></ul><p>15.<strong>类型转换</strong></p><ul><li>浮点数转换成整数不仅仅可能小数丢失，而且浮点数的整数值也可能超过int范围</li><li>c++还可以使用{}来初始化，这种初始化不允许出现精度丢失现象，比如浮点数赋予个整形，相同类型或者精度向上提升的的赋值可能被运行，条件是编译器知道会被正确赋值</li></ul><ol start="16"><li><strong>c++auto</strong></li></ol><ul><li>在初始化声明中，如果使用auto，而不指定关键字类型，编译器将把变量类型设置为与初始值相同</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto n=100;//n is int</span><br><span class="line">auto a= 100.1//a is double</span><br><span class="line">double x=0;/x=0.0 is double</span><br><span class="line">auto y =0;//y=0,y is int</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章&quot;&gt;&lt;a href=&quot;#第三章&quot; class=&quot;headerlink&quot; title=&quot;第三章&quot;&gt;&lt;/a&gt;第三章&lt;/h2&gt;&lt;p&gt;1.&lt;strong&gt;变量名&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c99（标准c）中只保证名称的前63个字符有意义，前63个字
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title> c++如果两个在不同头文件如何相互引用</title>
    <link href="http://yoursite.com/2019/05/09/c-%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/09/c-如果两个在不同头文件如何相互引用/</id>
    <published>2019-05-09T06:02:00.000Z</published>
    <updated>2019-05-09T06:02:41.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-如果两个在不同头文件如何相互引用"><a href="#c-如果两个在不同头文件如何相互引用" class="headerlink" title="c++如果两个在不同头文件如何相互引用"></a>c++如果两个在不同头文件如何相互引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个不同类相互引用，需要放入对方的头文件，但是如果分别放入<code>#include seconde.h  #include seconde.h</code>那么会产生重复编译的问题<br>但是可以改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class b；//提前声明</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">#include first.h//引入头文件</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br><span class="line">//同时这几个.h的实现文件.cpp只用引入其中一个头文件即可，不需要同时引入两个</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;c-如果两个在不同头文件如何相互引用&quot;&gt;&lt;a href=&quot;#c-如果两个在不同头文件如何相互引用&quot; class=&quot;headerlink&quot; title=&quot;c++如果两个在不同头文件如何相互引用&quot;&gt;&lt;/a&gt;c++如果两个在不同头文件如何相互引用&lt;/h3&gt;&lt;figure
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="头文件" scheme="http://yoursite.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MarKDown语法</title>
    <link href="http://yoursite.com/2019/05/08/MarKDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/08/MarKDown语法/</id>
    <published>2019-05-08T01:56:00.000Z</published>
    <updated>2019-05-08T02:10:32.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h3><ol><li><strong>标题</strong></li></ol><p>#这是一级标题</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><p>##这是二级标题（<em>以此类推，级数越大，标题越小,空格后加内容</em>）</p><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p>2.<strong>字体</strong></p><p>   1.<em>傾斜</em></p><pre><code>*字*</code></pre><p>   <em>字</em></p><p>   2.<em>粗体</em></p><pre><code>**字**</code></pre><p>   <strong>字</strong></p><p>   3.<em>倾斜加粗</em></p><pre><code>***字***</code></pre><p>   <strong><em>字</em></strong></p><p>   4.<em>删除线</em></p><pre><code>~~字~~</code></pre><p>   <del>字</del></p><p>3.<em>引用</em></p><pre><code>&gt;引用内容</code></pre><blockquote><p>引用内容</p></blockquote><p>4.<em>分割线</em></p><p>-–(三个以上都行，下同)</p><hr><p>***</p><hr><p>5.<em>图片</em></p><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可    不加</code></pre><p>6.<em>超链接</em></p><pre><code>[链接名][网址]</code></pre><p>7.<em>列表</em></p><pre><code>+ or - or * 列表（注意空格）</code></pre><ul><li>列表<pre><code>1. or 2. --- 列表1</code></pre></li></ul><ol><li>列表</li></ol><p>8.<em>表格</em></p><pre><code>|  |  || --- | --- |(分割线)|  |  |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td></tr></tbody></table><ol start="9"><li><p><em>代码</em><br> 单行代码  </p><p> `int mian`</p><p> <code>main</code> </p><p> 代码块</p><p> ```  ```</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>（要打出特殊符号，在前面加TAb即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="MarkDown语法" scheme="http://yoursite.com/tags/MarkDown%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/05/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/线段树/</id>
    <published>2019-05-07T15:48:00.000Z</published>
    <updated>2019-05-08T02:05:44.509Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define lSon a*2+1</span><br><span class="line">#define rSon a*2+2</span><br><span class="line">using namespace std;</span><br><span class="line">double scatter[100];//不确定生成数据，所以动态开辟</span><br><span class="line">void upDate(int);</span><br><span class="line">void signDown(int);</span><br><span class="line">struct edg</span><br><span class="line">&#123;</span><br><span class="line">    double L;//实际的左右端点</span><br><span class="line">    double R;</span><br><span class="line">&#125;;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int lHand;//区间左端点</span><br><span class="line">    int rHand;//区间右端点</span><br><span class="line">    int nums;//这个区间的线段数</span><br><span class="line">    int counts;</span><br><span class="line">    int rF;//区间左端点是否被覆盖</span><br><span class="line">    int lF;//区间右端点是否被覆盖</span><br><span class="line">    double len;//区间长度</span><br><span class="line">    Node():lHand(0),rHand(0),nums(0),rF(0),lF(0),len(0),counts(0)//初始化</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[MAX*4];//线段树是完全树</span><br><span class="line">void Tree(int a,int lhand,int rhand)//建树</span><br><span class="line">&#123;</span><br><span class="line">    int mid=(lhand+rhand)/2;</span><br><span class="line">    tree[a].lHand=lhand;</span><br><span class="line">    tree[a].rHand=rhand;</span><br><span class="line">    if(lhand==rhand)</span><br><span class="line">        return;</span><br><span class="line">    Tree(lSon,lhand,mid);</span><br><span class="line">    Tree(rSon,mid+1,rhand);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int a,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a].counts)</span><br><span class="line">        signDown(a);</span><br><span class="line">    int mid=(tree[a].lHand+tree[a].rHand)/2;</span><br><span class="line">    if(tree[a].lHand&gt;=l&amp;&amp;tree[a].rHand&lt;=r)//如果被完全包含</span><br><span class="line">    &#123;</span><br><span class="line">        if(tree[a].counts)</span><br><span class="line">            return;</span><br><span class="line">        tree[a].counts++;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].lF=1;</span><br><span class="line">        tree[a].rF=1;</span><br><span class="line">        tree[a].len=scatter[tree[a].rHand+1]-scatter[tree[a].lHand];</span><br><span class="line">        //需要向右扩展</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mid&gt;=l)</span><br><span class="line">        insert(lSon,l,r);</span><br><span class="line">    if(mid&lt;r)</span><br><span class="line">        insert(rSon,l,r);</span><br><span class="line">    upDate(a);//合并左右子树信息</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void upDate(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a*2+1].rF&amp;tree[a*2+2].lF)//如果端点都为1，合并</span><br><span class="line">    &#123;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">    tree[a].nums=tree[a*2+1].nums+tree[a*2+2].nums;</span><br><span class="line">    tree[a].lF=tree[a*2+1].lF;</span><br><span class="line">    tree[a].rF=tree[a*2+2].rF;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void signDown(int a)</span><br><span class="line">&#123;</span><br><span class="line">    tree[a*2+1].len=scatter[tree[a*2+1].rHand+1]-scatter[tree[a*2+1].lHand];</span><br><span class="line">    tree[a*2+2].len=scatter[tree[a*2+2].rHand+1]-scatter[tree[a*2+2].lHand];</span><br><span class="line">    tree[a*2+1].lF=1;</span><br><span class="line">    tree[a*2+1].rF=1;</span><br><span class="line">    tree[a*2+2].lF=1;</span><br><span class="line">    tree[a*2+2].rF=1;</span><br><span class="line">    tree[a*2+1].nums=1;</span><br><span class="line">    tree[a*2+1].counts=1;</span><br><span class="line">    tree[a*2+2].nums=1;</span><br><span class="line">    tree[a*2+2].counts=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T,i=0,t=0;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    edg e[T];</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        double L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        scatter[i++]=L;</span><br><span class="line">        scatter[i++]=R;</span><br><span class="line">        e[t].L=L;//存储边的信息</span><br><span class="line">        e[t++].R=R;</span><br><span class="line">    &#125;</span><br><span class="line">sort(scatter,scatter+i);</span><br><span class="line">int size=unique(scatter,scatter+i)-scatter;</span><br><span class="line">Tree(0,0,size);</span><br><span class="line">for(int j=0;j&lt;t;j++)</span><br><span class="line">&#123;</span><br><span class="line">    int LH=lower_bound(scatter,scatter+size,e[j].L)-scatter;</span><br><span class="line">    int RH=lower_bound(scatter,scatter+size,e[j].R)-scatter;</span><br><span class="line">    insert(0,LH,RH-1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;tree[0].len&lt;&lt;&quot; &quot;&lt;&lt;tree[0].nums&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树因为建树要求区间是整数所以如果要插入浮点数那么需要进行离散化，即根据数据之间的相对关系找到对应整数的对应关系。找到合适的线段插入，但是可能后面需要插的线段再原线段的下方，为了能获取线段覆盖数信息，需要进行标记传，因为线段树可能会找不到左右子树之间的距离，所以考虑每个结点向右扩展1位，即[a,b)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://yoursite.com/2019/05/03/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/03/字典树/</id>
    <published>2019-05-03T03:44:00.000Z</published>
    <updated>2019-05-03T03:47:07.727Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node//结点</span><br><span class="line">&#123;</span><br><span class="line">    bool isEnd;//是否是最后一个结点，判断是否完全匹配</span><br><span class="line">    Node*son[26];//子结点，一共26个字母</span><br><span class="line">    char val;//当前结点值</span><br><span class="line">    long long num;//当前结点与父结点的距离</span><br><span class="line">    Node(char x=&apos;a&apos;):isEnd(false),num(0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            son[i]=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()//析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(son[i])</span><br><span class="line">                delete son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Tree//树</span><br><span class="line">&#123;</span><br><span class="line">    Node*root;</span><br><span class="line">    Tree()</span><br><span class="line">    &#123;</span><br><span class="line">        root=new Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Tree head;//头,字典树头节点不包含信息</span><br><span class="line">void insert_str(string s)//字符串为空，返回</span><br><span class="line">&#123;</span><br><span class="line">    if(s.size()==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，那么开辟空间</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;son[i]=new Node(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;isEnd=true;//插入的最后一个字符，标记</span><br><span class="line">&#125;</span><br><span class="line">bool query(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if(!s.size())</span><br><span class="line">        return false;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，不匹配</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    return temp-&gt;isEnd;//可能是部分匹配</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    string s;</span><br><span class="line">    while(T--)//建树，插入字符串</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        insert_str(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(query(s))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">             cout&lt;&lt;&quot;no exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典树本质是一种文本快速匹配算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus学习</title>
    <link href="http://yoursite.com/2019/05/03/c-Primer-Plus%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/03/c-Primer-Plus学习/</id>
    <published>2019-05-02T16:25:00.000Z</published>
    <updated>2019-05-10T07:15:59.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>1.<strong>main函数</strong></p><ul><li>在c++中<br><code>int  main（）</code><br><code>int main(void)</code><br>是等价的，都代表是不接受参数，但是在c中代表对是否有参数保持沉默</li><li>c++标准中，主函数返回值必须为int，如果运行到主函数最后一个花括号，那么认为以这条语句结束<br><code>return 0</code></li></ul><p>2.<strong>头文件命名</strong></p><ul><li>c++旧式命名规则时和c语言一样的，以.h结束，比如<code>iostream.h</code>,只能c++用，c不行</li><li>c的头文件<code>.h</code>c++一般都可以兼容<br>+c有些头文件被转换为了c++风格，名字一般是c版本名+前缀c<br>比如<code>cmath math.h</code></li></ul><p>3.<strong>endl与\n的区别</strong></p><ul><li>在大多数时候两者都没有区别，但是endl能保证程序继续运行前刷新（输出到显示屏）但是<code>\n</code>不能保证。</li></ul><p>4.<strong>分隔符 ；</strong></p><ul><li>c++以；作为代码语句结束的标志，在编辑代码过程中，回车和空格是没有区别的，能打空格就能打回车，例如，下面这条语句是正确的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a;int b;</span><br><span class="line">    cout</span><br><span class="line">    &lt;&lt;</span><br><span class="line">    endl;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ul><p>但是也要遵循一些规则,不能把空格，回车，TAB放入元素当中，比如函数名字，不能在字符串中打回车，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ma in()//error</span><br><span class="line">&#123;</span><br><span class="line">cou</span><br><span class="line">t&lt;&lt;&quot;hello</span><br><span class="line">world&quot;;//eroor,字符串中打了空格（carriage return）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.<strong>赋值语句 =</strong></p><ul><li>c++区别与c的地方就是c++允许进行连续赋值，即下面代码是对的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=b=10//从右到左赋值</span><br></pre></td></tr></table></figure></li></ul><p>6.<strong>在多函数里使用using编译命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;//对后面所有定义的函数都有影响</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespcae std;//对主函数影响</span><br><span class="line">    cout&lt;&lt;1;</span><br><span class="line">    std::cout&lt;&lt;1;//完整输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;main函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在c++中&lt;br&gt;&lt;code&gt;int  main（）&lt;
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
      <category term="c++ primer plus" scheme="http://yoursite.com/categories/c/c-primer-plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>快速幂算法</title>
    <link href="http://yoursite.com/2019/04/28/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/28/快速幂算法/</id>
    <published>2019-04-28T04:02:00.000Z</published>
    <updated>2019-05-03T03:44:52.763Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt; iostream&gt;</span><br><span class="line">#include&lt; stdio.h&gt;</span><br><span class="line">#define  ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int kpow(ll a,ll b);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    kpow(2,32);</span><br><span class="line">&#125;</span><br><span class="line">int kpow(ll a,ll b)//int kpow(lla,llb,int c)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans=1,base=a,temp=b;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1!=0)#任何大于0的数除以2以后，最终都会为1</span><br><span class="line">        ans*=base;//ans=ans*base%c</span><br><span class="line">        base*=base;//base=(base*base)%c</span><br><span class="line">        cout&lt;&lt;base&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld的%lld次方为：%lld\n&quot;,a,temp,ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  快速幂本质上<br><img src="\images\pasted-2.png" alt="upload successful">,如果是取数取余数(中间结果取余相乘即可)，见代码注释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Ipython安装 </title>
    <link href="http://yoursite.com/2019/04/26/Ipython%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/04/26/Ipython安装/</id>
    <published>2019-04-26T15:33:00.000Z</published>
    <updated>2019-04-26T15:39:14.614Z</updated>
    
    <content type="html"><![CDATA[<p>1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库</p><p>2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库&lt;/p&gt;
&lt;p&gt;2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa&lt;/p&gt;

      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA安装及环境配置（window10系统+jdk8.0）</title>
    <link href="http://yoursite.com/2019/04/26/JAVA%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88window10%E7%B3%BB%E7%BB%9F-jdk8-0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/26/JAVA安装及环境配置（window10系统-jdk8-0）/</id>
    <published>2019-04-26T15:01:00.000Z</published>
    <updated>2019-05-03T03:41:51.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li>jdk的下载</li></ol><p><img src="\images\pasted-1.png" alt><br><a href="http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可" target="_blank" rel="noopener">http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可</a><br>    2.jdk的安装</p><pre><code>* 在D盘新建一个java文件夹，在java文件下新建两个文件夹，分别命名为jdk和jre.* 开始点击安装程序， 安装时有两次选择路径的机会，第一次是让你选择jdk安装路径，选择为D:\java\jdk，第二次是让你选择jre的安装路径，选择为D:\java\jre* .安装完成后，进行环境变量的配置，计算机右击属性，-高级系统设置-环境变量-选择下边的系统变量，如果桌面上没有 我的电脑 打开文件夹，点击那里的我的电脑* 新建* 变量名：JAVA_HOME* 变量值：D:\java\jdk（没有分号）* 变量名：ClassPath* 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;* 查看是否有path变量，如果没有创建一个，然后添加 C:\ProgramData\Oracle\Java\javapath;* 应为Javac和java不在同一个包里，所以添加变量* D:\java\jdk\bin* D:\java\jre\bin* 按win+R，输入cmd,打开命令提示符，输入Java，javac，Java-version* 均能运行表示Java安装成功，* 返回最开始的网站，下载eclipse编译器（idle位数的选择取决于你jdk的版本是32还是64），既可以写Java程序了，无需安装，解压即可。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;jdk的下载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;\images\pasted-1.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;amp;pn
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>const char*, char const*, char*const的区别问题</title>
    <link href="http://yoursite.com/2019/04/26/const-char-char-const-char-const%E7%9A%84%E5%8C%BA%E5%88%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/26/const-char-char-const-char-const的区别问题/</id>
    <published>2019-04-26T14:19:03.000Z</published>
    <updated>2019-04-26T14:57:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>const char<em>, char const</em>, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。<br>char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。指针指向的值可以变（例如允许：p[1]=’O’;）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const char&lt;em&gt;, char const&lt;/em&gt;, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。&lt;br&gt;char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客初创</title>
    <link href="http://yoursite.com/2019/04/26/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%88%9B/"/>
    <id>http://yoursite.com/2019/04/26/博客初创/</id>
    <published>2019-04-26T13:29:37.000Z</published>
    <updated>2019-04-26T15:37:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>第一次写博客，花了不少时间搭建服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次写博客，花了不少时间搭建服务器&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
