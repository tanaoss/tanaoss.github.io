<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赤羽</title>
  
  <subtitle>人生没有白走的路，每一步都算数</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-29T10:06:38.619Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tanghao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++ Primer Plus（第八章）</title>
    <link href="http://yoursite.com/2019/05/29/c-Primer-Plus%EF%BC%88%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/29/c-Primer-Plus（第八章）/</id>
    <published>2019-05-29T10:04:00.000Z</published>
    <updated>2019-05-29T10:06:38.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>1.<strong>内联函数</strong></p><ul><li>在函数声明前加上inline</li><li>在函数定义前加上inline</li><li>虽然请求为内联函数，但是不一定编译器使用，比如函数递归或者函数过大</li></ul><p>2.<strong>引用变量</strong></p><ul><li>引用变量需要在声明时定义，否则报错，并且捆绑后，不能解绑，类似与const指针</li><li>引用变量作为函数参数传入时候，必须是变量，否则报错，比如f（a+3）;//错误 (f(int &amp;))</li></ul><p>3.<strong>临时变量，引用参数，const</strong></p><ul><li><p>如果实参与引用参数不匹配，将会生成临时变量，c++11以后只有const引用才会，但之前的不是这样（也就是说，如果不匹配，尽管是引用，但是实际函数传入的型参是经过转化后的匿名参数，和原来没有关系，你如果改变了临时参数也不影响原来的实参）</p></li><li><p><strong>左值</strong> 左值是指可以可被引用的数据对象，非左值包括：字面常量（常量字符串，7，4.2等字面量）,以及包含多项的表达式</p></li><li><p>const引用创建临时变量的情况</p><pre><code>+  实参类型正确，但不是左值+  实参类型不正确，但可以被转换 </code></pre></li><li><p>函数定义形参有const使函数能够处理const和非const实参，否则只接受非const</p></li><li>c++新增右值引用，这种引用可指向右值（非左值），比如<code>int &amp;&amp; =2.0* j</code> </li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">int f(const int&amp;);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //int&amp; a=10;不能是字面量</span><br><span class="line">    int j=10;</span><br><span class="line">    //int&amp; a=j*10;不能是表达式</span><br><span class="line">    //long&amp; a=j;新标准c++中非const引用不支持转换</span><br><span class="line">    const long&amp; a=j;</span><br><span class="line">    f(a);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int f(const int&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    int b=a;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>引用做返回值</strong></p><ul><li>确保返回的引用所绑定的变量不是临时变量</li><li>返回引用的函数是左值，及可以放在等号左边，然后传统的返回却不行</li></ul><p>5.<strong>默认参数</strong></p><ul><li>对于带参数的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，必须为他右边的所有参数提供默认值（否则产生二义性）</li></ul><p>6.<strong>函数模板</strong></p><p>+在函数前面加 template &lt;typename(class) Anytype&gt; Anytype是指程序员自己定义的名字</p><ul><li>模板函数的调用为 f<t>();(显示调用)，实例化<br>+f();隐式调用</t></li></ul><p>7.<strong>模板重载</strong></p><ul><li>和常规函数重载一样，带模板的函数重载需要其特征不同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a,T&amp; b);//origin</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Swap(T a[],T  b[]);//new</span><br></pre></td></tr></table></figure><p>8.<strong>为特定类型提供具体化的模板定义</strong></p><ul><li>对于给定的函数名，可以右非模板函数，模板函数和显示具体化模板函数以及他们的重载版本</li><li>显式具体化的原型和定义应为template&lt;&gt;打头，并通过名称指出类型</li><li>显示具体化优先于常规模板，而非模板函数优先于显示具体化</li><li>显示具体化的使用 ：<code>tempale&lt;&gt; void swap&lt;int&gt;(int,int)</code> 使用template <int>代表这是一个int的具体化，参数表以及表明了，所有可以不写</int></li></ul><p>9.<strong>显式具体化与显式实例化</strong></p><ul><li>使用<code>template void f&lt;int&gt;()</code>表示显式告诉编译器实例化具体的函数</li></ul><p>10.<strong>编译器使用函数的版本</strong></p><ul><li>当有多个模板匹配的时候，编译器会选择一个最佳方式进行匹配，如果不存在，会返回一个二义性的错误</li><li>指向const的指针和数据优先于非const的，非模板函数优先于模板</li><li>两个完全匹配的模板函数，较具体化的模板函数优先 ,即<code>f(T a),f(T * a)</code> 后者会优先匹配</li><li>寻找最佳的过程被称之为重载解析</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第八章&quot;&gt;&lt;a href=&quot;#第八章&quot; class=&quot;headerlink&quot; title=&quot;第八章&quot;&gt;&lt;/a&gt;第八章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;内联函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数声明前加上inline&lt;/li&gt;
&lt;li&gt;在函数定义
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus (第七章）</title>
    <link href="http://yoursite.com/2019/05/25/c-Primer-Plus/"/>
    <id>http://yoursite.com/2019/05/25/c-Primer-Plus/</id>
    <published>2019-05-24T16:37:00.000Z</published>
    <updated>2019-05-24T16:40:08.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>1.<strong>函数与指针</strong></p><ul><li>int sum(int a[],int n);a[]在函数中实际代表一个指针，在c++中当且仅当用于函数头或者函数原型时候 int a[]与int* a相同</li><li>函数中需要传入数组长度而非用sizeof计算的原因是，传入函数的是指针而非数组，计算得到的是对应指针变量的长度</li><li>int sum(const int a[],int n)；const限制为只读，int sum(const int [],int n)；也是一样</li></ul><p>2.<strong>函数与二维数组</strong></p><ul><li><p>函数中传入二维数组的方式为</p><pre><code>+ sum(int a[][4],int size);+ sum(int (*a)[4],int int size);//代表第一个元素是一个数组，这个数组有size个对象+ //sum(int * a[4],int  size) ;是错误的，这样不代表二维数组，而是指针数组，表示四个指向int 的指针+ 这种方式传入与直接写成传入int * 是不同的，通过显式传入获得数据需要使用两次 * ，而int * 只要一次（同时需要强制转换数组名为一维指针）</code></pre><p>3.<strong>返回c风格的字符串</strong></p><ul><li>如果要在函数中返回字符数组，应该使用new关键字，静态数组函数结束会被销毁</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void f1(int *a,int size);</span><br><span class="line">void f2(int a[][4],int size);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;1+1,2,3,4&#125;,&#123;1,2,3,4&#125;&#125;;//可以使用加号</span><br><span class="line">    f1((int*)a,12);//因为是显示使用指针，所以不能用a[][]来索引，会编译出错,同时需要强制转换</span><br><span class="line">    f2(a,3);</span><br><span class="line">&#125;</span><br><span class="line">void f2(int a[][4],int size)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void f1(int* a,int size)</span><br><span class="line">&#123;</span><br><span class="line">        for(int j=0;j&lt;size;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*a++&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>函数指针</strong></p><ul><li>以前觉得函数指针没啥作用，不过现在觉得函数指针的真的作用蛮大的，就类似与stl的sort第三个参数，通过函数指针就能确定不同的排序方式</li><li>函数名就是函数地址 比如 f()，f就是函数地址</li><li>函数指针的声明，int(* p)(int),代表一个指针有一个参数是int，返回值是int的函数，声明之后赋值即可，注意括号不可以省略</li><li>使用函数指针调用函数 , p(int)与（* p）(int)等价</li><li>声明函数指针数组[],放在变量名后面，例如int(* p[])(int),</li><li>auto p=f，来定义p的类型很方便，因为有些函数类型很麻烦的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第七章&quot;&gt;&lt;a href=&quot;#第七章&quot; class=&quot;headerlink&quot; title=&quot;第七章&quot;&gt;&lt;/a&gt;第七章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;函数与指针&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int sum(int a[],int n);a[]在函
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>刷题</title>
    <link href="http://yoursite.com/2019/05/17/%E5%88%B7%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/17/刷题/</id>
    <published>2019-05-17T11:30:00.000Z</published>
    <updated>2019-05-17T11:30:47.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1041-困于环中的机器人"><a href="#1041-困于环中的机器人" class="headerlink" title="1041. 困于环中的机器人"></a>1041. 困于环中的机器人</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/" target="_blank" rel="noopener">困于环中的机器人 </a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isRobotBounded(string instructions) &#123;</span><br><span class="line">        int X[]&#123;0,-1,0,1&#125;,y[]&#123;1,0,-1,0&#125;;</span><br><span class="line">        int px(0),py(0),z(0),flag(0);</span><br><span class="line">        instructions=instructions+instructions+instructions+instructions;//如果为一条循环指令，那么值至少是完整周期的1/4</span><br><span class="line">        for(auto x:instructions)</span><br><span class="line">        &#123;</span><br><span class="line">            if(x==&apos;G&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                px+=X[z];</span><br><span class="line">                py+=y[z];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(x==&apos;L&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                z=(z+1)%4;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                z=(z+3)%4;</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            return !px&amp;&amp;!py;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>解释：因为一次是90°，如果机器人能一直在环中，那么若干条指令后会恢复初始状态，所以一条指令最多是1/4分之一的周期，不可能是1/5之类的，应为方向回到最初之后如果还没回到最初位置就说明在偏移。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1041-困于环中的机器人&quot;&gt;&lt;a href=&quot;#1041-困于环中的机器人&quot; class=&quot;headerlink&quot; title=&quot;1041. 困于环中的机器人&quot;&gt;&lt;/a&gt;1041. 困于环中的机器人&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcod
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title> c++文件读取中文乱码</title>
    <link href="http://yoursite.com/2019/05/16/c-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://yoursite.com/2019/05/16/c-文件读取中文乱码/</id>
    <published>2019-05-16T03:32:00.000Z</published>
    <updated>2019-05-16T03:33:24.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-文件读取中文乱码"><a href="#c-文件读取中文乱码" class="headerlink" title="c++文件读取中文乱码"></a>c++文件读取中文乱码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">string UTF8ToGB(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">     string result;</span><br><span class="line">     WCHAR *strSrc;</span><br><span class="line">     LPSTR szRes;</span><br><span class="line"></span><br><span class="line">     //获得临时变量的大小</span><br><span class="line">     int i = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);</span><br><span class="line">     strSrc = new WCHAR[i+1];</span><br><span class="line">     MultiByteToWideChar(CP_UTF8, 0, str, -1, strSrc, i);</span><br><span class="line"></span><br><span class="line">     //获得临时变量的大小</span><br><span class="line">     i = WideCharToMultiByte(CP_ACP, 0, strSrc, -1, NULL, 0, NULL, NULL);</span><br><span class="line">     szRes = new CHAR[i+1];</span><br><span class="line">     WideCharToMultiByte(CP_ACP, 0, strSrc, -1, szRes, i, NULL, NULL);</span><br><span class="line"></span><br><span class="line">     result = szRes;</span><br><span class="line">     delete []strSrc;</span><br><span class="line">     delete []szRes;</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ifstream inFile;//输出类</span><br><span class="line">    inFile.open(&quot;text.txt&quot;);//&lt;&lt;,setf(),endl都可以用到这个对象</span><br><span class="line">    char line[80];</span><br><span class="line">    inFile.getline(line,80);</span><br><span class="line">string    msg=UTF8ToGB(line);</span><br><span class="line">    cout&lt;&lt;msg;</span><br><span class="line">    inFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博文：[<a href="https://blog.csdn.net/zhancf/article/details/49930969" target="_blank" rel="noopener">https://blog.csdn.net/zhancf/article/details/49930969</a><br>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;c-文件读取中文乱码&quot;&gt;&lt;a href=&quot;#c-文件读取中文乱码&quot; class=&quot;headerlink&quot; title=&quot;c++文件读取中文乱码&quot;&gt;&lt;/a&gt;c++文件读取中文乱码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus (第六章)</title>
    <link href="http://yoursite.com/2019/05/16/c-Primer-Plus-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/05/16/c-Primer-Plus-第六章/</id>
    <published>2019-05-16T03:31:00.000Z</published>
    <updated>2019-05-16T03:32:29.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><ol><li><strong>逻辑运算符细节</strong></li></ol><ul><li>c++ or 和 and 运算符低于 关系运算符，但是非（！）优先级高于关系运算符，所以要<strong>对比较结果取反,需要加括号</strong></li><li>c++ &amp;&amp;,|| ,~的另一种表达方式 对应关系为 and,or,not(他们均为c++保留字，c++不需要头文件使用他们，c需要)</li></ul><p>2.<strong>简单的文件处理</strong></p><ul><li>使用cin进士输入时，程序将输入视为一系列字节，即输入一开始都是字符数据，然后再根据类型转换</li><li>写入到文本文件<pre><code>+ 必须包含fstream+ 需要声明 ofstream 对象+ 需要绑定文件，open()方法+ 绑定后文件对象可以向cout那样使用</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ofstream outFile;//输出类</span><br><span class="line">    outFile.open(&quot;text.txt&quot;);//&lt;&lt;,setf(),endl都可以用到这个对象</span><br><span class="line">    outFile&lt;&lt;&quot;你哈&quot;;</span><br><span class="line">    outFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取文件<ul><li>必须包含fstream</li><li>需要声明 ifstream 对象</li><li>需要绑定文件，open()方法</li><li>绑定后文件对象可以向cin那样使用</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ifstream inFile;//输入类</span><br><span class="line">    inFile.open(&quot;text.txt&quot;);</span><br><span class="line">    char line[80];</span><br><span class="line">    inFile.getline(line,80);</span><br><span class="line">    cout&lt;&lt;line;//需要ANSI编码才能正确读写</span><br><span class="line">    inFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第六章&quot;&gt;&lt;a href=&quot;#第六章&quot; class=&quot;headerlink&quot; title=&quot;第六章&quot;&gt;&lt;/a&gt;第六章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;逻辑运算符细节&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;c++ or 和 and 运算
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus (第五章)</title>
    <link href="http://yoursite.com/2019/05/15/c-Primer-Plus-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/05/15/c-Primer-Plus-第五章/</id>
    <published>2019-05-15T10:29:00.000Z</published>
    <updated>2019-05-15T10:30:37.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>1.<strong>for循环</strong></p><ul><li>for循环是先判断再执行</li><li>测试语句为空，默认为true</li><li>c++11新增了基于范围的for循环，即<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double p[5];</span><br><span class="line">for(double x:p)</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>cout输出bool</strong></li></ol><ul><li><strong><em>&lt;&lt;(输出)的运算优先级比运算符高，所以如果希望输出运算后的值，最好用括号括起来</em></strong></li><li>c++会把bool值转换位int ，如果希望为bool最好前面加上<br><code>cout.setf(ios_base::boolalpha)</code></li><li>循环体执行完成以后才会对表达式进行更新，即执行for循环中第三条语句</li></ul><p>3.<strong>字符串比较</strong></p><ul><li><p>C语言风格：，由于常量字符串是地址，所以用直接比较是错的，应该使用strcmp函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a[8]=&quot;world&quot;;</span><br><span class="line">if(a==&quot;world&quot;)//all false,</span><br><span class="line">//应该改为if(strcmp(a,&quot;world&quot;))</span><br><span class="line">// 如果strcmp比较出字符串不等返回1，相等为0</span><br></pre></td></tr></table></figure></li><li><p>c+风格如果要比较的都是string对象（或者至少左边是一个string对象），直接用==判断</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第五章&quot;&gt;&lt;a href=&quot;#第五章&quot; class=&quot;headerlink&quot; title=&quot;第五章&quot;&gt;&lt;/a&gt;第五章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;for循环&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for循环是先判断再执行&lt;/li&gt;
&lt;li&gt;测试语句为空
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想（第三章）</title>
    <link href="http://yoursite.com/2019/05/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/13/Java编程思想（第三章）/</id>
    <published>2019-05-13T12:12:00.000Z</published>
    <updated>2019-05-13T12:13:16.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ol><li><strong>System.out.println()</strong></li></ol><ul><li>语句中包含“+”，不仅仅代表字符串连接，必要的时候还代表字符串转化，也就是，如果是数字，或者布尔值都会转换为对应的字符串，所有如果希望输出一个数字字符串，可以 这样写<em>“”+sum</em>，空字符串告诉编译器变成字符串</li><li>如果希望System.out.println()中的数字先运算再转换成数字，那么可以把他们括起来比如 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x=1,y=1;</span><br><span class="line">System.out.println(x+y);//11</span><br><span class="line">System.out.println((x+y));//2</span><br></pre></td></tr></table></figure><p>2.<strong>别名现象</strong></p><ul><li>Java中除了基本类型，其他对象的名字，都是指引用，设 c，d分别是某个对象名，那么c=d<strong>是c和d都有了同一个内存的引用</strong>，而不是简单的赋值</li></ul><p>3.<strong>一元减号</strong></p><ul><li>一元减号能使数据正负改变，比如 b=-b;</li></ul><p>4.<strong>关系运算符</strong></p><ul><li>Java中直接用对象名比较，是比较的对象的引用。要比较两个对象的内容是否相等，应该使用对象的equals（）方法，如果是自己实现的类，要重写覆盖继承的equals（）（父类默认比较引用）</li><li>Java中 <code>&amp;&amp; || ~</code>都只能用于布尔值，不像c++可以用非布尔值（c++把非零转换为true，零转换为false，Java不支持这种转换，事实上Java不支持所有可能造成精度丢失的转换，都要求程序员明确的指出强制转换）</li></ul><p>5.<strong>直接常量</strong></p><ul><li>直接常量Java会根据其值给一个类型，但是有的时候，与我们希望赋予的那个变量类型冲突，需要我们指出确定的后缀，比如f，D等 实例 float f=1e-43(1e-43编译器当作double处理，赋值个float会精度丢失，报错) 所有应该改为<code>float f=1e-43f</code></li><li>c++和Java都没有直接用常量表示二进制的方法，两者表示16和8进制的方式相同，但是Java Interger 和 long有toBinaryString（）方法 实例  <code>Interger.toBinaryString（8）</code></li></ul><p>6.<strong>位运算</strong></p><ul><li>Java新增 &gt;&gt;&gt;表示算术左移，即高位补零</li><li><strong>char ，byte ，short</strong>移位时候会先转换位int，移位完成再截断赋值，有些时候会出错，比如-1,(移位后可能还是-1，扩展为-1，32位1，移动10位，截断赋值后，还是全是1)</li></ul><p>7.<strong><em>Java中没有sizeof（和c++不同）</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第三章&quot;&gt;&lt;a href=&quot;#第三章&quot; class=&quot;headerlink&quot; title=&quot;第三章&quot;&gt;&lt;/a&gt;第三章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;System.out.println()&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;语句
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
      <category term="Java编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Java编程思想" scheme="http://yoursite.com/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>c++STL</title>
    <link href="http://yoursite.com/2019/05/13/c-STL/"/>
    <id>http://yoursite.com/2019/05/13/c-STL/</id>
    <published>2019-05-13T06:45:00.000Z</published>
    <updated>2019-05-13T06:54:20.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-STL常用容器（1）"><a href="#c-STL常用容器（1）" class="headerlink" title="c++STL常用容器（1）"></a>c++STL常用容器（1）</h3><p>1 .<strong>迭代器（iterator）</strong></p><ul><li>stl几乎所有容器都支持迭代器</li><li>迭代器的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums(10,1);</span><br><span class="line">    vector&lt;int&gt;::iterator it=nums.begain();//迭代器的声明，理解为 vector类中声明有iterator成员即可，还有begin（）方法，返回对应的迭代器即可，还有end（）方法，返回最后一个位置</span><br><span class="line">    cout&lt;&lt;*it;//输出迭代器此时指向的位置的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.<strong>数组转置（<algorithm>）</algorithm></strong></p><ul><li>reverse(v.begin(),v.end()); //数组转置</li></ul><p>3 <strong>排序（<algorithm> sort）</algorithm></strong></p><ul><li>sort(nums.begin(),nums.end()，function);//(默认是按升序排列,即从小到大)function参数选择排序方式，根据自己的选择来排序，比如，你希望一个二维数组可以根据第一维的大小来排序，就可以自己定义一个函数,是通过返回值的类型来判断谁排在前面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool complare(int a,int b)//根据数组类型选择传入参数，如果是原数组是vector&lt;vector&lt;int&gt;&gt;,则写vector&lt;int&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     return a&gt;b;//值大的排前面</span><br><span class="line">     //return S.id&lt;S1.id(id值小的结构体排前面)</span><br><span class="line"></span><br><span class="line">&#125;//从大到小排序，（返回值为true时的顺序为排序顺序）</span><br></pre></td></tr></table></figure><p>3.<strong>字符串</strong></p><ul><li>删除 （erase clear）<br> +s.erase(it + 1,it + 4); //删除s[1]-s[3]**注意：不删除最后一个位置，并且使用的是迭代器it<ul><li>clear（）//删除全部</li><li>s.erase(it+3);//删除s[3]</li></ul></li><li>查找（find）<ul><li>find找到string里面第一个要找到元素（char或者串），找到返回数组下标，找不到返回-1</li><li>int n = s1.find(‘e’);//fing和erase都是对象的方法</li><li>s1.find(‘h’,2); //从第二元素开始找<ul><li><strong>字符串与数字之间的相互转换</strong><br>+</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//字符串转数字（c++风格）定义于头文件 &lt;string&gt; </span><br><span class="line">std::stod(string);//将字符串转换成double类型的</span><br><span class="line">std::stoi(string);//将字符串转换成int类型的</span><br><span class="line">std::stoll(string);//将字符串转换成long long类型的</span><br><span class="line"></span><br><span class="line">//数字转字符串，对于浮点型，不稳定</span><br><span class="line">std::to_string(num]);//将字符串变成数字、、对于浮点类型， std::to_string 可能产生不期待的结果，因为返回的字符串中的有效位数能为零，见示例。double f4 = 1e-40;</span><br><span class="line">std::string f_str4 = std::to_string(f4); // 注意：返回 &quot;0.000000&quot;</span><br><span class="line">double f5 = 123456789;</span><br><span class="line">std::string f_str5 = std::to_string(f5);</span><br><span class="line">to_string: 123456789.000000</span><br><span class="line"></span><br><span class="line">//c语言风格 （stdio.h）</span><br><span class="line">//使用sprintf(char*, &quot;%.3f&quot;,num);</span><br><span class="line">//数字变字符串 </span><br><span class="line">//如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</span><br><span class="line">        char a[10]=&#123;0,0,0,&apos;\0&apos;&#125;;</span><br><span class="line">        float t=(float)sum/1000;</span><br><span class="line">        sprintf(a, &quot;%.3f&quot;,t);</span><br><span class="line">        //同理还有scanf</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>字符数组与字符串的相互转换</strong></li></ol><ul><li>字符数组转字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">char a[10]=&quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">string s(&amp;a[0],&amp;a[9]);///起始位置 结束长度位置 +1</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;//可以更换数字下标运行看看</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串转字符数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">string s=&quot;0123456789&quot;;</span><br><span class="line"></span><br><span class="line">char op[15];</span><br><span class="line"></span><br><span class="line">strncpy(op,s.c_str(),s.length()+1);///s.c_str() 字符强制转化为字符串函数</span><br><span class="line"></span><br><span class="line">///长度必须加1，\0还占一个位置</span><br><span class="line"></span><br><span class="line">for(int i=0;op[i];i++)</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;op[i]&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">      printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;c-STL常用容器（1）&quot;&gt;&lt;a href=&quot;#c-STL常用容器（1）&quot; class=&quot;headerlink&quot; title=&quot;c++STL常用容器（1）&quot;&gt;&lt;/a&gt;c++STL常用容器（1）&lt;/h3&gt;&lt;p&gt;1 .&lt;strong&gt;迭代器（iterator）&lt;/st
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="STL" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/STL/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="stl" scheme="http://yoursite.com/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus(第四章）</title>
    <link href="http://yoursite.com/2019/05/13/c-Primer-Plus-%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/13/c-Primer-Plus-第四章）/</id>
    <published>2019-05-13T05:29:00.000Z</published>
    <updated>2019-05-13T05:36:01.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>1.<strong>数组初始化规则</strong></p><ul><li>数组不能相互赋值，因为数组名本质上是const指针</li><li>数组如果不用花括号进行初始化，那么值是未知的，如果未全部初始化，即花括号元素小于数组大小，那么编译器将会把其他元素全部初始化为0（所以把数组所有元素初始化的方式是显式设置为0）</li><li><strong><em>c++11新规则</em></strong> <ul><li>初始化数组时候，可省略等号，大括号内可以不以不包含元素，系统默认设置为0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count[10]&#123;&#125;;//元素全部被设置为0，同时这种列表初始化方式不允许，精度丢失的转换</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li><strong>字符串</strong></li></ol><ul><li><p><em>字符串与字符数组</em></p><ul><li>字符数组如果没有显式包含’\0’,那么不是字符串，只是字符数组，反之为字符串（将之当作字符串处理使用一些库函数将出错）</li></ul></li><li><p>c++中允许以下的方式初始化（不必显式包含’\0’）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char [10]=&quot;hello&quot;;//“hello”字符串隐式包含&apos;\0&apos;</span><br></pre></td></tr></table></figure></li><li><p>c++输入工具通过键盘输入时，将字符串读入到char数组时，将自动加上结尾的’\0’;</p></li><li><p>以字符串常量初始化数组时，应该保证数组足够，能装下字符串+’\0’</p></li><li><p><em>“S”=’S’+’\0’;</em> 注意与单个字符不一致</p></li><li><p><em>字符常量拼接</em></p><ul><li>事实上，任何两个由空白（空格，制表符和换行符）分隔的字符串常量都将自动拼接为一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;&quot;hello world&quot;;</span><br><span class="line">cout&lt;&lt;&quot;hello &quot; &quot;world&quot;;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;</span><br><span class="line">&quot;world&quot;;</span><br><span class="line">//这三种输出均等价</span><br><span class="line">//应该注意，拼接时不会在连接的字符串中添加空格。第一个字符串的\0将被第二个字符串的第一个字符覆盖</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="3"><li><p><strong>字符串cin输入</strong></p><ul><li><code>cin</code>用空白（空格，制表符，换行）作为字符串的结束位置，也就是说，如果使用<code>cin&gt;&gt;str</code>,来为str赋值，那么输入的字符串不能被空白符间隔开来，否则系统将会留下后半部分在队列中，等待下一次输入，同时作为结束标志的换行符会被留在队列</li></ul></li><li><p><strong>读取一行的输入</strong></p><ul><li>基于上面所说的问题，iostream中的类（如<code>cin</code>),提供了一些类成员函数<ul><li>getline（）<ul><li>getline（）函数读取整行，他使用通过回车键来确定输入结尾。调用 <code>cin.getline()</code>.该函数有两个参数，第一个参数用来存储输入行的存贮地址，即数组名。第二个参数是读取字符数（包括\0）,即参数设置为20，那么最多读取19个字符。(<strong><em>在碰到换行符或者到达指定的数目时停止读取,(并且丢弃换行符(丢弃指缓冲区都没),如果是以换行符结束</em></strong>)</li></ul></li><li>get()<ul><li>get()接受参数与工作方式与getline（）相似，但是并不丢弃（<strong>但也不读取，而是留在缓冲区（带参数的get（name，len））</strong>）\n,而是将其留在输入队列。即连续两次读取，第二次读取将会应为读取到\n，而终止</li><li>get（）的重载函数，不带参数的get（）可读取<strong>下一个字符</strong>，即使<strong>是换行符\n</strong>,可以使用这个函数来吸收留在缓冲区的换行符</li></ul></li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cin.get(name,len);//返回一个cin对象</span><br><span class="line">cin.get();</span><br><span class="line">//上面两句等价与 cin.get(name,len).get();</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>空行和其他问题</strong></li></ol><ul><li>get（）（不是getline（））读取空行后将设置失效位置（failbit）阻断输入，可以使用cin.clear();来恢复<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char s1[20],s2[30],s3[30],s4;</span><br><span class="line">    cin.get(s1,20);</span><br><span class="line">    cin.get();</span><br><span class="line">    cin.get(s2,20);//空行</span><br><span class="line">    cin.get();</span><br><span class="line">    cin.get(s3,20);</span><br><span class="line">    puts(s1);</span><br><span class="line">    puts(s2);</span><br><span class="line">    puts(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>程序截屏<br><img src="\images\TIM图片20190511162243.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char s1[20],s2[30],s3[30],s4;</span><br><span class="line">    cin.get(s1,20);</span><br><span class="line">    cin.get();</span><br><span class="line">    cin.get(s2,20);//空行</span><br><span class="line">    cin.clear();//读取空行后，应该立即重新设置，否则get（）无法读取换行符，产生错误</span><br><span class="line">    cin.get();</span><br><span class="line">    cin.get(s3,20);</span><br><span class="line">    puts(s1);</span><br><span class="line">    puts(s2);</span><br><span class="line">    puts(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序截屏<br><img src="\images\TIM图片20190511162448.png" alt="1dcd7dccec6a39b13e3dd9ce2032c49e.png"></p><ul><li>当输入字符串长于可分配空间，get()和getline（）将把余下的字符留在缓冲区，getline（）还会设置失效位，关闭后面的输入</li></ul><p>6.<strong>String</strong></p><ul><li>c++11允许使用列表初始化字符串和字符数组 string s1={“hello”}</li><li><em>string 的赋值拼接和附加</em><ul><li>string类变量允许使用等号直接赋值，字符数组不行</li><li>string类可是使用+号合并两个字符串，使用+=追加字符串</li><li>string 类 + 等价与 c的strcop（charr1，charr2）：第一个，第二个参数都为数组名，函数的意义是把第二个参数赋值给第一个，但是有可能因为数组长度问题，发生内存错误</li><li>+=等价对于strcat（charr1，charr2）：c++中，第二个可以为字符串常量，<em>如果字符串常量大于数组的，那么不会为数组添加\0,并且剩余部分继续覆盖，可能会覆盖其他程序所需要使用的内存</em></li></ul></li></ul><p>7.<strong>string类i\o</strong></p><ul><li>string 类处理字符串与字符数组不同，处理字符串默认按行读取</li><li>声明一个string对象，但是不初始化那么系统默认为零，但是会随着后面的输入而自动变化</li><li>输出string的类方法（非&gt;&gt;）getline(cin,stringob);</li></ul><p>8.<strong>c++结构体的特性</strong></p><ul><li>c++中结构体可以有成员函数</li><li><em>c++结构体初始化</em> inflatable duck{X,x};,如果花括号为空，那么所以成员都会被初始化为0 </li></ul><p>9.<strong>位字段</strong></p><ul><li>在结构体正常的声明后面加：和数字，数字代表这个变量所被允许使用的位数</li></ul><p>10.<strong>共用体</strong></p><ul><li>共用体除了关键字位union，其他声明与结构体相同，不同的是共用体共用地址，所以共用体大小取决与最大那一给变量，（通过使用共用体的不同变量完成类型转换，<em>名共用体所有成员成为相同地址的变量，相当于同一地址的不同名称（但是与类型有光）</em></li></ul><p>11.<strong>枚举</strong></p><ul><li>枚举只有赋值=运算符，不存在+，++等</li><li>枚举只能被赋予花括号中声明的值（才有意义），但是可以通过在适当范围的整数强制转换位对应的枚举值，不在范围的被转换的结果是未知的</li><li>枚举值只能是<strong>整数（<code>long long</code> <code>long</code> <code>int</code>均可）</strong>，并且没显式指定的枚举值比前面的大1，如果都没指定，那么第一个默认0，<strong>枚举值可以显式指定为相同</strong></li></ul><p>12.<strong>指针</strong></p><ul><li>c++中int* 是一种复合类型，表示int类型的指针</li><li>int<em> p1,p2`，**</em>p1是指针，p2是int变量<em>**！对于c++中每个指针变量都需要一个</em></li></ul><p>13.<strong>new与delete</strong></p><ul><li>new（凡是动态开辟的变量）存在堆中，int，double等在堆栈</li><li><em>new开辟的动态空间存class对象才会自动调用构造函数和析构函数</em></li><li><strong>delete删除的内存并不会删除指针，所以需要将指针重新指向</strong></li><li>对已经delete的空间delete将会产生不确定的结果</li><li>删除多个连续空间，用delete[] p;</li></ul><p>13.<strong>数组名与指针的区别</strong></p><ul><li>指针可以指向其他地方，但是数组名不能，代表一个常量</li><li>sizeof算指针是指针的长度（1），但是算数组名是数组长度</li><li>int arr[10] &amp;arr和arr在值上是相同的,都是地址的值，但是arr等价于&amp;arr[0],这代表对arr+1每次加4，指向数组下一个int元素，但是&amp;arr+1（arr+10）,一次加的数组长度</li><li>给指针赋值相当于给给指针一个地址，两个指针指向同一块地址</li></ul><p>14.<strong>指针与字符串</strong></p><ul><li>字符串常量相当于其首地址</li><li>c++并不能保证字符串字面值被唯一的存储，也就是说相同字面值的字符串，可能有多个副本也可能一个</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;数组初始化规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组不能相互赋值，因为数组名本质上是const指针&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想（第二章）</title>
    <link href="http://yoursite.com/2019/05/11/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/11/java编程思想（第二章）/</id>
    <published>2019-05-11T10:07:00.000Z</published>
    <updated>2019-05-13T12:14:21.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>1.<strong>标识符与对象的关系</strong></p><ul><li>java中一切标识符都是对象的引用而不是对象</li></ul><ol start="2"><li><strong>程序运行对象的存储</strong></li></ol><ul><li><em>寄存器</em>：Java中没有类似与c++，c的建议寄存器存储的地方</li><li><em>堆栈</em>：java中某些数据直接存储在堆栈中-特别是对象的引用（标识符），但是对象不存储在其中</li><li><em>堆</em>： 存放所有的Java对象，但是在堆中存储分配和清理可能比在用堆栈更消耗时间</li><li><em>常量存储</em>：通常在程序代码内部，如 <em>字符串池</em></li><li><em>非RAM存储</em>： 不受程序控制，运行时可以存在也可以不存在</li></ul><p>3.<strong>基本类型</strong></p><ul><li>Java与c++一样，对于基本类型（int ，float），创建一个并非是引用的变量，这个变量直接存储值，并放在堆栈中，而不是new</li><li>Java中基本类型的存储空间是固定的，而并不是与硬件架构有关，并且不存在无符号的数值类型，boolean(布尔，与c++的bool)大小没有明确指定，仅仅定义为能够取字面值的true或者false<br><img src="\images\TIM图片20190511165348.png" alt="05.png"></li></ul><p>+基本类型具有包装器类，使堆中可以创建一个非基本对象，来表示对应的基本类型，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//基本类型与非基本对象表示的基本类型的转换</span><br><span class="line">char x=&apos;x&apos;;</span><br><span class="line">Character ch =new Character(x);//Character ch =new Character(&apos;x&apos;);</span><br><span class="line">char c=ch//反向转换</span><br></pre></td></tr></table></figure></p><ol start="4"><li><strong>高精度数字</strong></li></ol><ul><li>java提供两个用来高精度计算的类 BigInteger BigDeclmal,包装类但不存在基本类型对应，运算速度满但是精度高</li></ul><p>5.<strong>java中的数组</strong></p><ul><li>java确保数组会被初始化，而且不能在范围之外被访问</li><li>创建一个数组对象时，实际创建的是一个引用数组，并将每个数组初始化为null</li><li>基本类型数组会被初始化为0</li></ul><p>6.<strong>作用域</strong></p><ul><li>Java与c++类似，；代表语句结束，空白符不影响代码执行</li><li><p>Java不允许较大作用域的变量被较小的隐藏 ，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int x=12;</span><br><span class="line">    &#123;</span><br><span class="line">        int x=96;//c++中是对的，但是Java是错的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java对象的生命周期可以存在作用域之外，但引用的作用域会消失，事实证明：new出来的对象，只要你需要就会一直保存下去（Java垃圾回收机制会处理掉那些不需要的对象）</p></li></ul><p>7.<strong>成员函数与数据成员</strong></p><ul><li>Java中数据成员如果是某个对象的引用，那么需要正确将其初始化，与实际对象相关联，否则报错</li><li>如果数据成员是基本数据类型，那么Java会为其初始化，boolean初始化为false ，char为’\u0000’(null),其他均为对应的0，比如0f，0L等</li><li>如果是<strong>成员函数中定义的变量，那么Java不为它初始化</strong>,如果程序员不初始化，会报错</li></ul><ol start="8"><li><strong>传递过程中的变化</strong></li></ol><ul><li>java在传递过程中通常是传递的引用，除了int 等基本数据类型（<strong>通过堆栈进行函数传递</strong>）</li><li>java无论在何处都会要去强制返回一个正确的返回值</li></ul><p>9.<strong>名字的可见性</strong></p><ul><li>java通过反转域名来保证名字是独一无二的，比如 MindVew.net,则应用工具库被命名为net.MindView.XX.反转后，句点表示划分</li><li>java中，包名均为小写</li></ul><ol start="10"><li><strong>类的调用</strong></li></ol><ul><li>通过import导入其他类，通过通配符*导入包中所有类</li></ul><p>11.<strong>static关键字</strong></p><ul><li>通过static关键字声明的事物，不与对象相关联，可以通过类名直接访问，（所有类都共用那一个变量的实际上是同一个存储位置）</li></ul><ol start="12"><li><strong>默认包</strong></li></ol><ul><li>java.lang是默认导入每个Java文件，所以可以直接使用</li></ul><p>13<strong>main的参数</strong></p><ul><li>public statcic void main(String[] args)的参数是编译器要求的，即使没有使用，不能删除,这个数组存储命令行参数.</li></ul><p>14.<strong>注释文档</strong></p><ul><li>/**开始，结束与*/,</li><li>三种类型注释文档<ul><li>类注释 位于类定义之前</li><li>域注释 位于域定义之前</li><li>方法注释 位于方法域之前</li></ul></li><li>注释文档能通过javaoc输出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;标识符与对象的关系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java中一切标识符都是对象的引用而不是对象&lt;/
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
      <category term="Java编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus(第三章)</title>
    <link href="http://yoursite.com/2019/05/10/c-Primer-Plus-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/05/10/c-Primer-Plus-第三章/</id>
    <published>2019-05-10T07:14:00.000Z</published>
    <updated>2019-05-10T07:37:02.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>1.<strong>变量名</strong></p><ul><li>c99（标准c）中只保证名称的前63个字符有意义，前63个字符相同的名称被认为是相同的，c++对名字长度没有限制（但某些平台会有限制）</li><li>c++中以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的被保留给实现，用作全局标识符（例：如果使用_time_s,_Doun等变量名，编译器不会报错，但会导致行为不确定性）</li></ul><p>2.<strong>变量长度</strong><br>+<code>short</code>,<code>long</code>,<code>int</code>等并不总是保证16，32，32.但是c++标准保证了<code>最小长度</code>，即 short 至少16位，int与short至少是一样长，long至少32为，且至少与int一样长，long long至少64位，且至少和long一样长</p><p>3.<strong>sizeof运算符</strong></p><ul><li>对于sizeof运算符（算内存）对类型名必须要放入括号中，但是对  <strong><em>变量名，括号是可选的</em></strong></li></ul><p>4.<strong>头文件climits（极限数据头文件）</strong></p><ul><li>头文件climit 定义了符号常量来表示类型的限制 比如<code>INT_MAX</code>表示int的最大值，比较常用的有 INT_MIN(int最小值) ，UNIT_MAX(无符号int最大值),LLNOG_MAX(long long最大值)，ULLNOG_MAX(无符号long long最大值)等</li></ul><p>5.<strong>c++变量初始化</strong></p><ul><li>c++还包含一种与C语言不同的初始方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b(100);//The New</span><br><span class="line">int c&#123;12&#125;;</span><br><span class="line">int v=&#123;12&#125;;</span><br><span class="line">int e=&#123;&#125;;//e=0</span><br></pre></td></tr></table></figure></li></ul><p>6.<strong>无符号类型</strong></p><ul><li>unsigned 本身是 unsigned int的缩写</li></ul><p>7.<strong>c++记数方式</strong></p><ul><li>c++能够和C语言一样，以8，10，16进制计数，如果第一位是1-9，那么基数是10，如果第一位是0，第二位是1~7，基数是7，如果前两位是0x或者0X，那么是十六进制；</li></ul><p>8.<strong>c++常量</strong></p><ul><li><code>cout&lt;&lt;12;</code>c++除非有理由（数太大或者后缀）存储为其他类型，则一般存储为int</li><li>后缀LU，UL均表示无符号整数，与顺序无关</li></ul><p>8.<strong>基于字符的8进制与16进制转义</strong></p><ul><li>Ctr+Z的ASII码为26，对应八进制为032，16进制为0x1a，，用单引号括起，即对应编码，如’\037’</li></ul><p>9 <strong>bool</strong></p><ul><li>c++中，任何数字值和指针值都可以被转换为（隐式）为bool，非零为true，零为false。而bool值true转换为1，false为0</li></ul><p>10.<strong>浮点数</strong></p><ul><li>浮点数可以表示为234.0等价于2.34E（e）2(表示2.34与10^2相乘的结果)，同时<strong>数字必须紧挨，不能有空格</strong>，比如 2.34 E2是错误的</li></ul><p>11.<strong>浮点数的输出</strong></p><ul><li>cout输出一般会省去浮点数结尾的零，使用<code>cout.self(ios_base::fixed,ios_base::floatfield);</code>可以覆盖掉</li></ul><p>12.<strong>浮点数常量</strong></p><ul><li>long double的后缀是 l或者L，float是f或者F，c++默认是double</li></ul><p>13.<strong>c++求模</strong></p><ul><li>如果两操作数有一个负数，那么运算满足 （a/b)*b+a%b=a;</li><li>两操作数都因该是整数，浮点数会编译错误</li></ul><ol start="14"><li><strong>浮点数精度问题</strong></li></ol><ul><li>float保证6位精度，double保证15位精度</li></ul><p>15.<strong>类型转换</strong></p><ul><li>浮点数转换成整数不仅仅可能小数丢失，而且浮点数的整数值也可能超过int范围</li><li>c++还可以使用{}来初始化，这种初始化不允许出现精度丢失现象，比如浮点数赋予个整形，相同类型或者精度向上提升的的赋值可能被运行，条件是编译器知道会被正确赋值</li></ul><ol start="16"><li><strong>c++auto</strong></li></ol><ul><li>在初始化声明中，如果使用auto，而不指定关键字类型，编译器将把变量类型设置为与初始值相同</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto n=100;//n is int</span><br><span class="line">auto a= 100.1//a is double</span><br><span class="line">double x=0;/x=0.0 is double</span><br><span class="line">auto y =0;//y=0,y is int</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章&quot;&gt;&lt;a href=&quot;#第三章&quot; class=&quot;headerlink&quot; title=&quot;第三章&quot;&gt;&lt;/a&gt;第三章&lt;/h2&gt;&lt;p&gt;1.&lt;strong&gt;变量名&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c99（标准c）中只保证名称的前63个字符有意义，前63个字
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title> c++如果两个在不同头文件如何相互引用</title>
    <link href="http://yoursite.com/2019/05/09/c-%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/09/c-如果两个在不同头文件如何相互引用/</id>
    <published>2019-05-09T06:02:00.000Z</published>
    <updated>2019-05-10T07:38:09.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-如果两个在不同头文件如何相互引用"><a href="#c-如果两个在不同头文件如何相互引用" class="headerlink" title="c++如果两个在不同头文件如何相互引用"></a>c++如果两个在不同头文件如何相互引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个不同类相互引用，需要放入对方的头文件，但是如果分别放入<code>#include seconde.h  #include seconde.h</code>那么会产生重复编译的问题<br>但是可以改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//first.h</span><br><span class="line">class b；//提前声明</span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">    friend class b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//seconde.h</span><br><span class="line">#include first.h//引入头文件</span><br><span class="line">class b</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">b*a;</span><br><span class="line">&#125;</span><br><span class="line">//同时这几个.h的实现文件.cpp只用引入其中一个头文件即可，不需要同时引入两个</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;c-如果两个在不同头文件如何相互引用&quot;&gt;&lt;a href=&quot;#c-如果两个在不同头文件如何相互引用&quot; class=&quot;headerlink&quot; title=&quot;c++如果两个在不同头文件如何相互引用&quot;&gt;&lt;/a&gt;c++如果两个在不同头文件如何相互引用&lt;/h3&gt;&lt;figure
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="头文件" scheme="http://yoursite.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MarKDown语法</title>
    <link href="http://yoursite.com/2019/05/08/MarKDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/08/MarKDown语法/</id>
    <published>2019-05-08T01:56:00.000Z</published>
    <updated>2019-05-08T02:10:32.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h3><ol><li><strong>标题</strong></li></ol><p>#这是一级标题</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><p>##这是二级标题（<em>以此类推，级数越大，标题越小,空格后加内容</em>）</p><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p>2.<strong>字体</strong></p><p>   1.<em>傾斜</em></p><pre><code>*字*</code></pre><p>   <em>字</em></p><p>   2.<em>粗体</em></p><pre><code>**字**</code></pre><p>   <strong>字</strong></p><p>   3.<em>倾斜加粗</em></p><pre><code>***字***</code></pre><p>   <strong><em>字</em></strong></p><p>   4.<em>删除线</em></p><pre><code>~~字~~</code></pre><p>   <del>字</del></p><p>3.<em>引用</em></p><pre><code>&gt;引用内容</code></pre><blockquote><p>引用内容</p></blockquote><p>4.<em>分割线</em></p><p>-–(三个以上都行，下同)</p><hr><p>***</p><hr><p>5.<em>图片</em></p><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可    不加</code></pre><p>6.<em>超链接</em></p><pre><code>[链接名][网址]</code></pre><p>7.<em>列表</em></p><pre><code>+ or - or * 列表（注意空格）</code></pre><ul><li>列表<pre><code>1. or 2. --- 列表1</code></pre></li></ul><ol><li>列表</li></ol><p>8.<em>表格</em></p><pre><code>|  |  || --- | --- |(分割线)|  |  |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td></tr></tbody></table><ol start="9"><li><p><em>代码</em><br> 单行代码  </p><p> `int mian`</p><p> <code>main</code> </p><p> 代码块</p><p> ```  ```</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>（要打出特殊符号，在前面加TAb即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="MarkDown语法" scheme="http://yoursite.com/tags/MarkDown%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/05/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/线段树/</id>
    <published>2019-05-07T15:48:00.000Z</published>
    <updated>2019-05-10T07:40:22.942Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define lSon a*2+1</span><br><span class="line">#define rSon a*2+2</span><br><span class="line">using namespace std;</span><br><span class="line">double scatter[100];//不确定生成数据，所以动态开辟</span><br><span class="line">void upDate(int);</span><br><span class="line">void signDown(int);</span><br><span class="line">struct edg</span><br><span class="line">&#123;</span><br><span class="line">    double L;//实际的左右端点</span><br><span class="line">    double R;</span><br><span class="line">&#125;;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int lHand;//区间左端点</span><br><span class="line">    int rHand;//区间右端点</span><br><span class="line">    int nums;//这个区间的线段数</span><br><span class="line">    int counts;</span><br><span class="line">    int rF;//区间左端点是否被覆盖</span><br><span class="line">    int lF;//区间右端点是否被覆盖</span><br><span class="line">    double len;//区间长度</span><br><span class="line">    Node():lHand(0),rHand(0),nums(0),rF(0),lF(0),len(0),counts(0)//初始化</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[MAX*4];//线段树是完全树</span><br><span class="line">void Tree(int a,int lhand,int rhand)//建树</span><br><span class="line">&#123;</span><br><span class="line">    int mid=(lhand+rhand)/2;</span><br><span class="line">    tree[a].lHand=lhand;</span><br><span class="line">    tree[a].rHand=rhand;</span><br><span class="line">    if(lhand==rhand)</span><br><span class="line">        return;</span><br><span class="line">    Tree(lSon,lhand,mid);</span><br><span class="line">    Tree(rSon,mid+1,rhand);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int a,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a].counts)</span><br><span class="line">        signDown(a);</span><br><span class="line">    int mid=(tree[a].lHand+tree[a].rHand)/2;</span><br><span class="line">    if(tree[a].lHand&gt;=l&amp;&amp;tree[a].rHand&lt;=r)//如果被完全包含</span><br><span class="line">    &#123;</span><br><span class="line">        if(tree[a].counts)</span><br><span class="line">            return;</span><br><span class="line">        tree[a].counts++;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].lF=1;</span><br><span class="line">        tree[a].rF=1;</span><br><span class="line">        tree[a].len=scatter[tree[a].rHand+1]-scatter[tree[a].lHand];</span><br><span class="line">        //需要向右扩展</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mid&gt;=l)</span><br><span class="line">        insert(lSon,l,r);</span><br><span class="line">    if(mid&lt;r)</span><br><span class="line">        insert(rSon,l,r);</span><br><span class="line">    upDate(a);//合并左右子树信息</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void upDate(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[a*2+1].rF&amp;tree[a*2+2].lF)//如果端点都为1，合并</span><br><span class="line">    &#123;</span><br><span class="line">        tree[a].nums=1;</span><br><span class="line">        tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[a].len=tree[a*2+1].len+tree[a*2+2].len;</span><br><span class="line">    tree[a].nums=tree[a*2+1].nums+tree[a*2+2].nums;</span><br><span class="line">    tree[a].lF=tree[a*2+1].lF;</span><br><span class="line">    tree[a].rF=tree[a*2+2].rF;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void signDown(int a)</span><br><span class="line">&#123;</span><br><span class="line">    tree[a*2+1].len=scatter[tree[a*2+1].rHand+1]-scatter[tree[a*2+1].lHand];</span><br><span class="line">    tree[a*2+2].len=scatter[tree[a*2+2].rHand+1]-scatter[tree[a*2+2].lHand];</span><br><span class="line">    tree[a*2+1].lF=1;</span><br><span class="line">    tree[a*2+1].rF=1;</span><br><span class="line">    tree[a*2+2].lF=1;</span><br><span class="line">    tree[a*2+2].rF=1;</span><br><span class="line">    tree[a*2+1].nums=1;</span><br><span class="line">    tree[a*2+1].counts=1;</span><br><span class="line">    tree[a*2+2].nums=1;</span><br><span class="line">    tree[a*2+2].counts=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T,i=0,t=0;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    edg e[T];</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        double L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        scatter[i++]=L;</span><br><span class="line">        scatter[i++]=R;</span><br><span class="line">        e[t].L=L;//存储边的信息</span><br><span class="line">        e[t++].R=R;</span><br><span class="line">    &#125;</span><br><span class="line">sort(scatter,scatter+i);</span><br><span class="line">int size=unique(scatter,scatter+i)-scatter;</span><br><span class="line">Tree(0,0,size);</span><br><span class="line">for(int j=0;j&lt;t;j++)</span><br><span class="line">&#123;</span><br><span class="line">    int LH=lower_bound(scatter,scatter+size,e[j].L)-scatter;</span><br><span class="line">    int RH=lower_bound(scatter,scatter+size,e[j].R)-scatter;</span><br><span class="line">    insert(0,LH,RH-1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;tree[0].len&lt;&lt;&quot; &quot;&lt;&lt;tree[0].nums&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树因为建树要求区间是整数所以如果要插入浮点数那么需要进行离散化，即根据数据之间的相对关系找到对应整数的对应关系。找到合适的线段插入，但是可能后面需要插的线段再原线段的下方，为了能获取线段覆盖数信息，需要进行标记传，因为线段树可能会找不到左右子树之间的距离，所以考虑每个结点向右扩展1位，即[a,b)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://yoursite.com/2019/05/03/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/03/字典树/</id>
    <published>2019-05-03T03:44:00.000Z</published>
    <updated>2019-05-10T07:40:15.098Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node//结点</span><br><span class="line">&#123;</span><br><span class="line">    bool isEnd;//是否是最后一个结点，判断是否完全匹配</span><br><span class="line">    Node*son[26];//子结点，一共26个字母</span><br><span class="line">    char val;//当前结点值</span><br><span class="line">    long long num;//当前结点与父结点的距离</span><br><span class="line">    Node(char x=&apos;a&apos;):isEnd(false),num(0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            son[i]=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()//析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(son[i])</span><br><span class="line">                delete son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Tree//树</span><br><span class="line">&#123;</span><br><span class="line">    Node*root;</span><br><span class="line">    Tree()</span><br><span class="line">    &#123;</span><br><span class="line">        root=new Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Tree head;//头,字典树头节点不包含信息</span><br><span class="line">void insert_str(string s)//字符串为空，返回</span><br><span class="line">&#123;</span><br><span class="line">    if(s.size()==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，那么开辟空间</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;son[i]=new Node(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;isEnd=true;//插入的最后一个字符，标记</span><br><span class="line">&#125;</span><br><span class="line">bool query(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if(!s.size())</span><br><span class="line">        return false;</span><br><span class="line">    Node*temp=head.root;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       int pos=s[i]-&apos;a&apos;;</span><br><span class="line">        if(temp-&gt;son[i]==NULL)//如果不存在，不匹配</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp-&gt;son[i];//存在，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line">    return temp-&gt;isEnd;//可能是部分匹配</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    string s;</span><br><span class="line">    while(T--)//建树，插入字符串</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        insert_str(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(query(s))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">             cout&lt;&lt;&quot;no exist\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典树本质是一种文本快速匹配算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++ Primer Plus（第二章）</title>
    <link href="http://yoursite.com/2019/05/03/c-Primer-Plus%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/03/c-Primer-Plus学习/</id>
    <published>2019-05-02T16:25:00.000Z</published>
    <updated>2019-05-10T07:37:36.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>1.<strong>main函数</strong></p><ul><li>在c++中<br><code>int  main（）</code><br><code>int main(void)</code><br>是等价的，都代表是不接受参数，但是在c中代表对是否有参数保持沉默</li><li>c++标准中，主函数返回值必须为int，如果运行到主函数最后一个花括号，那么认为以这条语句结束<br><code>return 0</code></li></ul><p>2.<strong>头文件命名</strong></p><ul><li>c++旧式命名规则时和c语言一样的，以.h结束，比如<code>iostream.h</code>,只能c++用，c不行</li><li>c的头文件<code>.h</code>c++一般都可以兼容<br>+c有些头文件被转换为了c++风格，名字一般是c版本名+前缀c<br>比如<code>cmath math.h</code></li></ul><p>3.<strong>endl与\n的区别</strong></p><ul><li>在大多数时候两者都没有区别，但是endl能保证程序继续运行前刷新（输出到显示屏）但是<code>\n</code>不能保证。</li></ul><p>4.<strong>分隔符 ；</strong></p><ul><li>c++以；作为代码语句结束的标志，在编辑代码过程中，回车和空格是没有区别的，能打空格就能打回车，例如，下面这条语句是正确的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a;int b;</span><br><span class="line">    cout</span><br><span class="line">    &lt;&lt;</span><br><span class="line">    endl;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ul><p>但是也要遵循一些规则,不能把空格，回车，TAB放入元素当中，比如函数名字，不能在字符串中打回车，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ma in()//error</span><br><span class="line">&#123;</span><br><span class="line">cou</span><br><span class="line">t&lt;&lt;&quot;hello</span><br><span class="line">world&quot;;//eroor,字符串中打了空格（carriage return）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.<strong>赋值语句 =</strong></p><ul><li>c++区别与c的地方就是c++允许进行连续赋值，即下面代码是对的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=b=10//从右到左赋值</span><br></pre></td></tr></table></figure></li></ul><p>6.<strong>在多函数里使用using编译命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;//对后面所有定义的函数都有影响</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespcae std;//对主函数影响</span><br><span class="line">    cout&lt;&lt;1;</span><br><span class="line">    std::cout&lt;&lt;1;//完整输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;main函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在c++中&lt;br&gt;&lt;code&gt;int  main（）&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
      <category term="c++ Primer Plus" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-Primer-Plus/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++ Primer Plus " scheme="http://yoursite.com/tags/c-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>快速幂算法</title>
    <link href="http://yoursite.com/2019/04/28/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/28/快速幂算法/</id>
    <published>2019-04-28T04:02:00.000Z</published>
    <updated>2019-05-10T07:39:00.957Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt; iostream&gt;</span><br><span class="line">#include&lt; stdio.h&gt;</span><br><span class="line">#define  ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int kpow(ll a,ll b);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    kpow(2,32);</span><br><span class="line">&#125;</span><br><span class="line">int kpow(ll a,ll b)//int kpow(lla,llb,int c)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans=1,base=a,temp=b;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1!=0)#任何大于0的数除以2以后，最终都会为1</span><br><span class="line">        ans*=base;//ans=ans*base%c</span><br><span class="line">        base*=base;//base=(base*base)%c</span><br><span class="line">        cout&lt;&lt;base&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld的%lld次方为：%lld\n&quot;,a,temp,ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  快速幂本质上<br><img src="\images\pasted-2.png" alt="upload successful">,如果是取数取余数(中间结果取余相乘即可)，见代码注释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Ipython安装 </title>
    <link href="http://yoursite.com/2019/04/26/Ipython%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/04/26/Ipython安装/</id>
    <published>2019-04-26T15:33:00.000Z</published>
    <updated>2019-04-26T15:39:14.614Z</updated>
    
    <content type="html"><![CDATA[<p>1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库</p><p>2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.pip install ipython //这条指令会自动安装ipyton以及它的各种依赖库&lt;/p&gt;
&lt;p&gt;2.pip install jupyter//如果想在notebook或者Qt  console,还需要安装Jupytersa&lt;/p&gt;

      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA安装及环境配置（window10系统+jdk8.0）</title>
    <link href="http://yoursite.com/2019/04/26/JAVA%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88window10%E7%B3%BB%E7%BB%9F-jdk8-0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/26/JAVA安装及环境配置（window10系统-jdk8-0）/</id>
    <published>2019-04-26T15:01:00.000Z</published>
    <updated>2019-05-11T10:21:12.918Z</updated>
    
    <content type="html"><![CDATA[<ol><li>jdk的下载</li></ol><p><img src="\images\pasted-1.png" alt><br><a href="http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可" target="_blank" rel="noopener">http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;pn=Eclipse%20Installer&amp;pu=http://wiki.eclipse.org/Eclipse_Installer&amp;pi=http://download.eclipse.org/oomph/jre/128x128.png根据对应的电脑版本安装即可</a><br>    2.jdk的安装</p><pre><code>* 在D盘新建一个java文件夹，在java文件下新建两个文件夹，分别命名为jdk和jre.* 开始点击安装程序， 安装时有两次选择路径的机会，第一次是让你选择jdk安装路径，选择为D:\java\jdk，第二次是让你选择jre的安装路径，选择为D:\java\jre* .安装完成后，进行环境变量的配置，计算机右击属性，-高级系统设置-环境变量-选择下边的系统变量，如果桌面上没有 我的电脑 打开文件夹，点击那里的我的电脑* 新建* 变量名：JAVA_HOME* 变量值：D:\java\jdk（没有分号）* 变量名：ClassPath* 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;* 查看是否有path变量，如果没有创建一个，然后添加 C:\ProgramData\Oracle\Java\javapath;* 应为Javac和java不在同一个包里，所以添加变量* D:\java\jdk\bin* D:\java\jre\bin* 按win+R，输入cmd,打开命令提示符，输入Java，javac，Java-version* 均能运行表示Java安装成功，* 返回最开始的网站，下载eclipse编译器（idle位数的选择取决于你jdk的版本是32还是64），既可以写Java程序了，无需安装，解压即可。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;jdk的下载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;\images\pasted-1.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;http://download.eclipse.org/oomph/jre/?vm=1_1_7_0_64_0&amp;amp;pn
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>const char*, char const*, char*const的区别问题</title>
    <link href="http://yoursite.com/2019/04/26/const-char-char-const-char-const%E7%9A%84%E5%8C%BA%E5%88%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/26/const-char-char-const-char-const的区别问题/</id>
    <published>2019-04-26T14:19:00.000Z</published>
    <updated>2019-05-10T07:40:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>const char<em>, char const</em>, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。<br>char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。指针指向的值可以变（例如允许：p[1]=’O’;）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const char&lt;em&gt;, char const&lt;/em&gt;, 两者相同。指针指向的值是常量，不允许变。指针不是常量，它可以先指向a, 也可以变成再指向b（例如允许 p=a;p=b;)。&lt;br&gt;char*const，指针是常量，一旦初始化指向了a, 则不允许改变成指向b。
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c++" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客初创</title>
    <link href="http://yoursite.com/2019/04/26/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%88%9B/"/>
    <id>http://yoursite.com/2019/04/26/博客初创/</id>
    <published>2019-04-26T13:29:37.000Z</published>
    <updated>2019-04-26T15:37:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>第一次写博客，花了不少时间搭建服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次写博客，花了不少时间搭建服务器&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
